(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{148:function(e,r,t){"use strict";t.r(r);var s=t(9),a=Object(s.a)({},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p"),e._v(" "),t("blockquote",[t("p",[e._v("我只是要写个简单的 html 页面, 里面需要运行一些 js 来操作 DOM/BOM, 如果可能, 我希望利用 vue runtime")])]),e._v(" "),t("p",[t("strong",[e._v("注意")]),e._v("\n本文假设你已具有以下内容的相关知识或者实践经验:")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 单文件组件"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://vuejs.org/v2/guide/render-function.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 渲染函数"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/vuejs/babel-plugin-transform-vue-jsx",target:"_blank",rel:"noopener noreferrer"}},[e._v("jsx(Vue)"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"pugjs.org"}},[e._v("pug")])]),e._v(" "),t("li",[t("a",{attrs:{href:"https://babeljs.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel 及其相关插件"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"var"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#var","aria-hidden":"true"}},[e._v("#")]),e._v(" VAR")]),e._v(" "),t("p",[e._v("毫无疑问, 2016 ~ 2017 是 "),t("code",[e._v("Vue")]),e._v(" 势头最强劲的两年. 根据笔者的记忆, 2017 年, "),t("code",[e._v("Vue")]),e._v(" 的在 Github 上的 Star 数目首次超过 4W, 彼时 "),t("code",[e._v("React")]),e._v(" 的 star 数目还在 3W 内, "),t("code",[e._v("Angular")]),e._v(" v2/v4 还在 beta 版本. 三大框架互相学习, 尽管粉丝间掐架不少, "),t("a",{attrs:{href:"https://www.zhihu.com/question/63390665",target:"_blank",rel:"noopener noreferrer"}},[e._v("利益相关的布道者"),t("OutboundLink")],1),e._v("也上蹿下跳, 但 "),t("code",[e._v("Vue")]),e._v(" 2 引入了 vdom, 在实现上, 摆脱源自 "),t("code",[e._v("Angular")]),e._v(" 1.x 的模板概念; "),t("code",[e._v("Angular")]),e._v(" 和 "),t("code",[e._v("Vue")]),e._v(" 的作者之间还保持着互通有无的关系; React 升级后放弃了对 IE 8 的支持, 基于 S/P 模式的状态管理方案 "),t("code",[e._v("mobx")]),e._v(" 在社区冉冉升起.")]),e._v(" "),t("p",[e._v("时间步入 2018 年, VAR 三大框架在各方面的差异此消彼长, 甚至不约而同地对 "),t("code",[e._v("Typescript")]),e._v(' 做了官方的支持. 如果你在同一时间在项目中对三个框架都有实践, 难免会生出"万变不离其宗"的感慨: 说到底, 大家都玩起了'),t("strong",[e._v("预编译")]),e._v("和"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/render-function.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("渲染纯函数"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("进一步地说, "),t("a",{attrs:{href:"https://reactjs.org/docs/introducing-jsx.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("*.jsx(React)")]),t("OutboundLink")],1),e._v(" , angular 的组件 和 "),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("*.vue(sfc)")]),t("OutboundLink")],1),e._v(", 最终都会转化为 runtime 中对 DOM 不同的操作函数. 这一点在 "),t("a",{attrs:{href:"https://reactjs.org/docs/introducing-jsx.html",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("*.jsx(React)")]),t("OutboundLink")],1),e._v(" 中体现得淋漓尽致 —— 连 "),t("code",[e._v("*.jsx")]),e._v(" 这种语法的诞生都是为了让 React 组件的 createElement/cloneElement 函数对开发者更友好; "),t("code",[e._v("Vue")]),e._v(" 2 的"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html#ad",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v(" 将其包装成了模板中的 "),t("code",[e._v("v-*")]),e._v(" 指令、属性和事件绑定, 后来干脆也支持了 "),t("a",{attrs:{href:"https://github.com/vuejs/babel-plugin-transform-vue-jsx",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("*.jsx(Vue)")]),t("OutboundLink")],1),e._v(". 无论 *.jsx 还是 sfc, 这些框架的 DSL 语法, 都是为了尽可能地减少(乃至彻底清除)自家框架在运行时解析特定指令的耗时, 同时能让开发者有良好的开发体验.")]),e._v(" "),t("h2",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[e._v("#")]),e._v(" *.vue")]),e._v(" "),t("p",[e._v("对于 vue 新手而言, 直接在浏览器里引入完整版本的 vue.js 然后在 "),t("code",[e._v('<script type="text/x-template"><\/script>')]),e._v(" 中书写 "),t("a",{attrs:{href:"https://vuejs.org/v2/guide/components.html#X-Template",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 的 template"),t("OutboundLink")],1),e._v(" 是不错的开始, 但这样会导致 vue 在运行时,")]),e._v(" "),t("ol",[t("li",[e._v("先花费一部分时间去解析这段模板, 生成 vue 实例上的"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/render-function.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("渲染纯函数"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("运行这些"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/render-function.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("渲染纯函数"),t("OutboundLink")],1),e._v(", 处理 vue 实例中的 data 和 dom.")])]),e._v(" "),t("p",[e._v("其中的第 1 步, 通过使用"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v("是完全可以节省的.")]),e._v(" "),t("p",[e._v("vue 的"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v(" 是 xml 格式的文件, 经过 "),t("code",[e._v("Vue")]),e._v(" 官方工具链的处理(如使用基于  vue-cli 的 "),t("a",{attrs:{href:"https://github.com/vuejs/vue-cli/blob/dev/docs/README.md#webpack",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack"),t("OutboundLink")],1),e._v(" 的脚手架进行编译),后, 将变成可以在 "),t("code",[e._v("Vue")]),e._v(" runtime 中运行的的一系列纯函数集. 详情可参考"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("如果你还没安装 "),t("code",[e._v("vue-cli")]),e._v(" 并生成一个使用 "),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v(" 来构建应用的脚手架, 你可以通过 "),t("a",{attrs:{href:"https://template-explorer.vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-template-explorer"),t("OutboundLink")],1),e._v(" 了解 vue template 和编译后的"),t("a",{attrs:{href:"https://vuejs.org/v2/guide/render-function.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("渲染纯函数"),t("OutboundLink")],1),e._v("的联系.")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v(" 的优势很多, 比如:")]),e._v(" "),t("ul",[t("li",[e._v("通过 "),t("code",[e._v("webpack/browserify")]),e._v(" 的配置, 可以安心地使用 typescript/"),t("code",[e._v("es201X")]),e._v(" 的语法, 同时在编译后得到经过 polyfill 处理的、可以在 es5 环境下运行的代码")]),e._v(" "),t("li",[e._v("使用 css 和 html 预编译器")]),e._v(" "),t("li",[e._v("干净的组件内 scoped 特性.")]),e._v(" "),t("li",[e._v("配合 "),t("code",[e._v("webpack/browserify")]),e._v(", 使用 "),t("code",[e._v("nodejs")]),e._v(" 风格的模块管理.")])]),e._v(" "),t("p",[e._v("但在此前, "),t("a",{attrs:{href:"https://vuejs.org/v2/guide/single-file-components.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("单文件组件(sfc)"),t("OutboundLink")],1),e._v(" 有个缺陷, 即需要较为完整的 "),t("code",[e._v("vue-cli")]),e._v(" 工具链的支持, 如果你只是想:")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("写个简单的页面, 里面只有一个 ajax/fetch 请求, 根据返回结果, 在页面上渲染该结果")]),e._v(" "),t("li",[e._v("使用 vue")]),e._v(" "),t("li",[e._v("最好能够支持 jsx(Vue), 这样就不用")]),e._v(" "),t("li",[e._v("能直接书写 es6/typescript 语法, 并且能预编译为 es5 兼容的 js")]),e._v(" "),t("li",[e._v("还希望能够使用 less/stylus/scss/sass 来书写样式, 并预编译为合法的 css")])])]),e._v(" "),t("p",[e._v("此时最快的途径, 似乎是使用 "),t("code",[e._v("vue-cli")]),e._v(" 初始化一个 "),t("a",{attrs:{href:"https://github.com/vuejs-templates/webpack-simple",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-simple"),t("OutboundLink")],1),e._v(" 的项目, 然后修改 webpack 配置, 使得 "),t("code",[e._v("src/index.js")]),e._v(" 在编译后被注入 "),t("code",[e._v("index.html")]),e._v(", 得到一个页面.....稍等, 这类似于有时候你只是想写个简单的窗体应用, 却不得不去下载一个带完整 MFC 的 Visual Studio 一样. 我真的想这样做么? 我很可能配置 webpack 到一半就放弃了, 转而新建一个 "),t("code",[e._v("index.html")]),e._v(" 文件, 然后直接在 "),t("code",[e._v('<script type="text/x-template"><\/script>')]),e._v(" 里书写 vue 组件的模板, 然后运行起来 —— 尽管这样会引入完整的 "),t("code",[e._v("vue.js")]),e._v(" 的文件(> 100KB), 并且 vue 需要耗时去解析模板, 但是这样的开发效率, 非常高啊!")]),e._v(" "),t("h2",{attrs:{id:"别的思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#别的思路","aria-hidden":"true"}},[e._v("#")]),e._v(" 别的思路")]),e._v(" "),t("p",[e._v("即便是在 "),t("a",{attrs:{href:"https://github.com/vuejs/vue-component-compiler",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-component-compiler"),t("OutboundLink")],1),e._v(" 发布以后, 社区依然缺乏直接在 "),t("code",[e._v("index.html")]),e._v(" 中书写 vue 组件并且能进行预编译的方案.")]),e._v(" "),t("p",[e._v("那么, 如果我们只是想写个简单的页面(就像 jQuery 盛行的时代中我们经常做的那样), 我们非得安装 "),t("code",[e._v("vue-cli")]),e._v(", 再初始化项目, 再安装庞大的 "),t("code",[e._v("webpack")]),e._v(" 及其周边依赖么?")]),e._v(" "),t("p",[e._v("也许 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 适合做这件事, 它允许你在 "),t("code",[e._v("index.html")]),e._v(" 中直接引入相对路径下的 *.js 文件, 并根据 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 的配置(默认配置通常已足够你使用)合适地处理其中所有的资源, 包括 *.js 文件自身超前的语法("),t("code",[e._v("es201X")]),e._v(") 和 css 预编译器.")]),e._v(" "),t("p",[e._v("不过, 截至笔者书写到这里(北京时间 2018-02-11 17:14) 的时候, 根据 "),t("strong",[e._v("腾讯 imweb")]),e._v(" 的"),t("a",{attrs:{href:"http://imweb.io/topic/5a4451c3a192c3b460fce366",target:"_blank",rel:"noopener noreferrer"}},[e._v("尝试"),t("OutboundLink")],1),e._v(", "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 还有以下缺点:")]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("不支持SourceMap：在开发模式下，Parcel也不会输出SourceMap，目前只能去调试可读性极低的代码；")]),e._v(" "),t("li",[e._v("不支持剔除无效代码(TreeShaking)：很多时候我们只用到了库中的一个函数，结果Parcel把整个库都打包了进来；")]),e._v(" "),t("li",[e._v("一些依赖会让Parcel出错：当你的项目依赖了一些Npm上的模块时，有些Npm模块会让Parcel运行错误；")])])]),e._v(" "),t("p",[t("strong",[e._v("注意")]),e._v(" 实际上, 这些缺点在下文笔者介绍的方案中也存在. 相信以上问题 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 会在不久的未来解决.")]),e._v(" "),t("p",[e._v("也许我们可以尝试用 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 来写一个简单的页面, 但如果你希望去了解 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 内部处理资源的细节, 对自己的项目有更多的了解, 又不必太符合 "),t("a",{attrs:{href:"https://github.com/parcel-bundler/parcel",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("parcel")]),t("OutboundLink")],1),e._v(" 的社区形象(开箱即用, 零配置). 此时, 似乎 webpack 又更吸引你(尽管它的配置相对繁冗, 但至少对开发者可见)")]),e._v(" "),t("p",[e._v("有没有什么细节对开发者更为透明, 可以完全自己 DIY、不必造太多轮子的方案呢？如果抛开平时习惯 webpack/browserify 下的思维惯性, 整理一下, 其实真正帮助我们提高了效率的库是:")]),e._v(" "),t("ul",[t("li",[e._v("babel/bubble")]),e._v(" "),t("li",[e._v("JSX")]),e._v(" "),t("li",[e._v("pugjs/ejs/swig")]),e._v(" "),t("li",[e._v("stylus/less/scss/sass")])]),e._v(" "),t("p",[e._v('回到本文的初衷: "我只是要写个简单的 html 页面, 里面需要运行一些 js 来操作 DOM/BOM, 如果可能, 我希望利用 vue runtime". 为了满足这个需求, 笔者认为, 至少要解决以下两个问题:')]),e._v(" "),t("ul",[t("li",[t("input",{attrs:{type:"checkbox",disabled:""}}),e._v("   支持 js/css/html 预编译器")]),e._v(" "),t("li",[t("input",{attrs:{type:"checkbox",disabled:""}}),e._v("   以 html 为入口, 直接在 html 中书写超前的的预编译器语法")])]),e._v(" "),t("h3",{attrs:{id:"预编译器处理的一种接口标准-jstransformer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预编译器处理的一种接口标准-jstransformer","aria-hidden":"true"}},[e._v("#")]),e._v(" 预编译器处理的一种接口标准: jstransformer")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 是一系列 "),t("code",[e._v("jstransformer-*")]),e._v(" 的统称, "),t("a",{attrs:{href:"https://github.com/jstransformers/jstransformer",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformer"),t("OutboundLink")],1),e._v(" 的目的, 是统一 js(一般指nodejs) 社区中各类预编译器库的 API, 将不同思路、不同风格、不同目的, 但都基于 js、处理 js 或其它资源（比如 less/typescript）的库进行接口标准化. 参看其 github 上的 README:")]),e._v(" "),t("blockquote",[t("p",[e._v("There are many good template engines and compilers written for Node.js. But there is a problem: all of them have slightly different APIs, requiring slightly different usage. JSTransformer unifies them into one standardized API. Code written for one transformer will work with any other transformer.")]),e._v(" "),t("p",[e._v("(Node.js 社区中)有非常多好的模板引擎和模板编译器. 但是存在这样一个问题: 它们的 API 有些微差异, 用法有细微的不同. JSTransformer 将它们统一为标准的 API. 一个 transformer 应该能与另一个 transformer (以同样的 API)进行协作.")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 要处理的目标很明确: "),t("strong",[e._v("预编译器")]),e._v(", 比如下表中的这些预编译器")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("预编译器种类")]),e._v(" "),t("th",{staticStyle:{"text-align":"left"}},[e._v("典型库")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("html 预编译器")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[t("ul",[t("li",[e._v("pug/jade")]),e._v(" "),t("li",[e._v("ejs")]),e._v(" "),t("li",[e._v("juice")]),e._v(" "),t("li",[e._v("swig")])])])]),e._v(" "),t("tr",[t("td",[e._v("css 预编译器")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[t("ul",[t("li",[e._v("sass/scss")]),e._v(" "),t("li",[e._v("stylus")]),e._v(" "),t("li",[e._v("less")]),e._v(" "),t("li",[e._v("postcss")])])])]),e._v(" "),t("tr",[t("td",[e._v("js 预编译器")]),e._v(" "),t("td",{staticStyle:{"text-align":"left"}},[t("ul",[t("li",[e._v("coffeescript")]),e._v(" "),t("li",[e._v("babel")]),e._v(" "),t("li",[e._v("typescript")])])])])])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 让笔者想到 "),t("a",{attrs:{href:"https://webpack.js.org/loaders/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-loader"),t("OutboundLink")],1),e._v(" 概念. 尽管 "),t("a",{attrs:{href:"https://webpack.js.org/loaders/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-loader"),t("OutboundLink")],1),e._v(' 集成给 webpack 项目的类库不只是预编译器, 但在只讨论"如何在项目中使用预编译器"的语境下, '),t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 可以类比于 "),t("a",{attrs:{href:"https://webpack.js.org/loaders/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-loader"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("现在我们的第一个问题解决了")]),e._v(" "),t("ul",[t("li",[t("input",{attrs:{type:"checkbox",disabled:"",checked:""}}),e._v("   支持 js/css/html 预编译器")]),e._v(" "),t("li",[t("input",{attrs:{type:"checkbox",disabled:""}}),e._v("   以 html 为入口, 直接在 html 中书写超前的的 js 语法("),t("code",[e._v("es201X")]),e._v(")")])]),e._v(" "),t("h3",{attrs:{id:"直接在-html-中写预编译器语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接在-html-中写预编译器语法","aria-hidden":"true"}},[e._v("#")]),e._v(" 直接在 HTML 中写预编译器语法")]),e._v(" "),t("h4",{attrs:{id:"all-in-js-·pk·-html-first"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#all-in-js-·pk·-html-first","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("strong",[e._v("all-in-js")]),e._v(" ·PK· html-first")]),e._v(" "),t("p",[e._v("在考虑第二个问题之前, 先讨论一下目前社区对 html/css/js 前端三大基石的一种态度: "),t("strong",[e._v("all-in-js")])]),e._v(" "),t("p",[e._v("前两年, React 社区有一种 "),t("strong",[e._v("all-in-js")]),e._v(" 的思路, 即 html 提供一个页面载入的入口,  把所有的资源(包括所有的 css 一些体积可接受的图片)打包到 js 中, 这种思路倾向于:")]),e._v(" "),t("ul",[t("li",[e._v("如果不必要, css 可以完全不在 html 中书写(使用 "),t("code",[e._v("<style>")]),e._v(" 标签)或引入(使用 "),t("code",[e._v("<link>")]),e._v(" 标签)")]),e._v(" "),t("li",[e._v("html 文件除了 head 中的 meta 属性需要做一些定制, 其余部分基本不重要, 反正打包后的 js 会在 html 中注入开发者需要的一切.")])]),e._v(" "),t("p",[e._v("这种思路和 "),t("strong",[e._v("React 单页应用(SPA)")]),e._v(" 的配合可谓天衣无缝, 不止资源, 业务逻辑也 "),t("strong",[e._v("all-in-js")]),e._v(' , 这似乎没什么问题. 但过去社区对 html 语义化的努力的成果在这种思路下被严重削弱了: 反正对 SEO 也不友好, 我为什么要语义化？并且, 这种思路对一些简单的需求(比如"我就想写个静态页面, 里面有大量的静态元素, 就一个 input 中输入的内容需要被实时显示到另一个元素里")天然不太友好, 可能开发者只希望 vue 或者 React 处理页面中有动态渲染的元素, 其余相对静态的 DOM 元素留用于保持页面结构、语义表达(比如您现在正在阅读的这篇博客, 右边的标签列表就完全只是静态的 '),t("code",[e._v("ul > li")]),e._v(" 列表)")]),e._v(" "),t("p",[e._v("现在, 无论你使用 "),t("code",[e._v("vue-cli")]),e._v(" 还是 "),t("code",[e._v("create-react-app")]),e._v(", 这类工具都可以给你一个基于 webpack 的脚手架, 并鼓励你: "),t("strong",[e._v("all-in-(js/vue/react)")]),e._v(", 把 "),t("code",[e._v("Vue")]),e._v("/"),t("code",[e._v("React")]),e._v(" 的实例挂载到 body 元素下的一个根元素吧, 让 Vitural DOM 来为你处理一切...")]),e._v(" "),t("p",[e._v('那么问题来了, 如果我现在只是想写一篇博客, 但博客里有一些演示性的片段, 它只占了页面中的一小部分元素, 比如{% post_link fix-parse-date-error-in-chrome-50 "这篇文章" %}的末尾, 提供了一个小工具, 我希望使用 vue 来管理, 我可不希望把我所有的博客内容写在 vue 的组件里, 而是静态的 html, 毕竟, '),t("strong",[e._v("博客的文字是静态的")]),e._v(".")]),e._v(" "),t("p",[e._v("好, 现在我们写一个静态的 html 文件, 它可能是这样的:")]),e._v(" "),t("p",[e._v('{% include_code "样例博客" lang:html /assets/you-might-not-need-vue-sfc/sample-blog.html.raw %}')]),e._v(" "),t("p",[e._v("看起来似乎没什么问题, 但实际上, 我已经无意识地使用了 es6 的语法: 在 Vue 实例的 "),t("code",[e._v("data()")]),e._v(" 函数返回值中, 笔者竟然直接使用了 "),t("code",[e._v("inputstr")]),e._v(" 变量名作为返回对象的 key 名! 这在 es6 中是没问题的, 但在 es5 环境下, 这样的语法会导致致命错误.")]),e._v(" "),t("p",[e._v("在 webpack 环境下浸淫太久的开发者, 有时候可能忘记了某个特性是 es6 才支持的, 不自觉地在 html 的 "),t("code",[e._v("<script>")]),e._v(" 标签中直接使用了. 比如, 笔者经常使用的 "),t("code",[e._v("Array.from")]),e._v(" 是 es6 才支持的, 我希望能在 html 中毫无顾虑地使用它.")]),e._v(" "),t("p",[e._v("此时, 可能你开始怀念 webpack 脚手架为你提供的便利: 配好好 "),t("code",[e._v(".babelrc")]),e._v(" 和 "),t("code",[e._v("babal-loader")]),e._v(", 接下来在入口文件(可能命名为 "),t("code",[e._v("app.js")]),e._v(")及其引用文件中就可以放心地使用 "),t("code",[e._v("es201X")]),e._v(" 的新特性. 不过等等, 其实我们只是需要 babel 对吧? 将 es6 编译为 es5 甚至 es3 的, 是 "),t("strong",[e._v("babel 而非 webpack 啊")]),e._v("!")]),e._v(" "),t("p",[e._v("真的只有 grunt/gulp/browserify/webpack/parcel 这些方案可以让我们毫无顾忌地书写 es6 语法么? 真的必须在 html 中引入一个入口文件再让 babel 处理么?明明我们只是需要 babel 来编译下 es6.")]),e._v(" "),t("p",[e._v("有什么办法可以在 html 中书写的 javascript 直接被 babel 编译么?")]),e._v(" "),t("h3",{attrs:{id:"基于-pug-的预编译器集成方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于-pug-的预编译器集成方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 基于 pug 的预编译器集成方案")]),e._v(" "),t("p",[e._v("一个在 html 中直接使用 js/css 预编译器的方案是, 通过 "),t("a",{attrs:{href:"https://pugjs.org/language/filters.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("pug filters 特性"),t("OutboundLink")],1),e._v(", 在 HTML 中直接书写各种预编译器语法, 参看以下代码:")]),e._v(" "),t("p",[e._v('{% include_code "pug filters 举例" lang:pug /assets/you-might-not-need-vue-sfc/pug-filters.pug.raw %}')]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/jstransformers/jstransformer-babel",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformer-babel"),t("OutboundLink")],1),e._v(" 是一个可以将 babel 接口的标准化中间件. 根据 "),t("a",{attrs:{href:"https://pugjs.org/language/filters.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("pug filters 特性"),t("OutboundLink")],1),e._v(", 我可以在 pug 中书写一段 javascript, 将其置于一个 "),t("code",[e._v(":babel")]),e._v(" filter block 中, 并提前安装好 "),t("a",{attrs:{href:"https://github.com/jstransformers/jstransformer-babel",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformer-babel"),t("OutboundLink")],1),e._v(", 配置好 "),t("code",[e._v(".babelrc")]),e._v(", "),t("a",{attrs:{href:"https://github.com/jstransformers/jstransformer-babel",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformer-babel"),t("OutboundLink")],1),e._v(" 将自动帮我们把 es6 语法进行编码.")]),e._v(" "),t("h2",{attrs:{id:"一个更轻量的方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个更轻量的方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 一个更轻量的方案")]),e._v(" "),t("p",[e._v("综合以上分析, 基于 "),t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 和 "),t("a",{attrs:{href:"pugjs.org"}},[e._v("pug")]),e._v(", 抛开 "),t("code",[e._v("webpack")]),e._v(" 或者 "),t("code",[e._v("parcel")]),e._v(", 我们一样可以完美书写 "),t("code",[e._v("es201X")]),e._v(' 的语法(甚至 typescript/coffeescript). 实际上, {% post_link fix-parse-date-error-in-chrome-50 "这篇文章" %} 就使用 pug 书写静态内容的, 文章中所有的交互性区域, 使用 vue 管理; 部分需要在页面中特定书写的 css, 使用 '),t("code",[e._v("stylus")]),e._v(" 语法书写, 并由 "),t("a",{attrs:{href:"https://github.com/jstransformers/jstransformer-stylus",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformer-stylus"),t("OutboundLink")],1),e._v(" 进行编译.")]),e._v(" "),t("p",[e._v("至此, 我们解决了第二个问题,")]),e._v(" "),t("ul",[t("li",[t("input",{attrs:{type:"checkbox",disabled:"",checked:""}}),e._v("   支持 js/css/html 预编译器")]),e._v(" "),t("li",[t("input",{attrs:{type:"checkbox",disabled:"",checked:""}}),e._v("   以 html 为入口, 直接在 html 中书写超前的的 js 语法("),t("code",[e._v("es201X")]),e._v(")")])]),e._v(" "),t("p",[e._v("在这种方案中, 你可以自由地使用各种 "),t("a",{attrs:{href:"https://github.com/jstransformers",target:"_blank",rel:"noopener noreferrer"}},[e._v("jstransformers"),t("OutboundLink")],1),e._v(" 的库来编译你内容, 如果这些库不符合你的需要, 你也可以编写自己的脚本, 使用你自定义的 pug-fitler, 并使用 node.js 来运行.")]),e._v(" "),t("p",[e._v("为了更深入地讲解这种方案, 我写了一个"),t("a",{attrs:{href:"https://github.com/richardo2016/jstransformer_pug_sample",target:"_blank",rel:"noopener noreferrer"}},[e._v("示例项目"),t("OutboundLink")],1),e._v(", 并通过一个小系列来讨论一下这种方案的应用场景和它的局限性, 你可以从项目和系列文章中获得更多的关于这种方案的细节和应用场景. 如果你对这种项目感兴趣, 欢迎到项目 issue 中提出讨论, 或者发起 PR.")])])},[],!1,null,null,null);r.default=a.exports}}]);